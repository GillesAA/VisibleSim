
/**
 * @file FaultToleranceCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2024-03-07                                                                     
 **/
 
#include "FaultToleranceCode.hpp"
#include <algorithm>
#include <random>

FaultToleranceCode::FaultToleranceCode(Catoms3DBlock *host):Catoms3DBlockCode(host),module(host) {
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host) return;

    // Registers a callback (myBroadcastFunc) to the message of type R
    addMessageEventFunc2(BROADCAST_MSG_ID,
                         std::bind(&FaultToleranceCode::myBroadcastFunc,this,
                                   std::placeholders::_1, std::placeholders::_2));
    
    // Registers a callback (myAcknowledgeFunc) to the message of type K
    addMessageEventFunc2(ACKNOWLEDGE_MSG_ID,
                         std::bind(&FaultToleranceCode::myAcknowledgeFunc,this,
                                   std::placeholders::_1, std::placeholders::_2));

    addMessageEventFunc2(BROKEN_MSG_ID,
                        std::bind(&FaultToleranceCode::fromBrokenFunc,this,
                                std::placeholders::_1, std::placeholders::_2));


}


int FaultToleranceCode::reachableModules = 0;

void FaultToleranceCode::startup() {
    console << "start " << getId() << "\n";
    //module->setColor(RED);
    
    if (isA) { // At least one module must be "leader" in the config file
        //getWorld();
        module->setColor(RED);
        currentRound=1;
        distance=0;
        maxd=0;
        int nb = FaultToleranceCode::breakInterfaces(0.6);
        cout << "nb:" << nb  << endl;
        for(int i=0; i<module->getNbInterfaces(); i++) {
            if(not brokenInterfaces[i] and module->getInterface(i)->isConnected()) {
                sendMessage("flood msg",new Message(BROADCAST_MSG_ID),module->getInterface(i),1000,100);
            }
        }    
    }	
}

void FaultToleranceCode::myBroadcastFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
    Message *msg = static_cast<MessageOf<tuple<int,int,int>>*>(_msg.get());
 
    if ( parent==nullptr ) {
        reachableModules++;
        cout << "ReachableModules: " << reachableModules << endl;
        parent = sender;
        for(int i=0; i<module->getNbInterfaces(); i++) {
            if(not brokenInterfaces[i] and module->getInterface(i)->isConnected()) {
                sendMessage("flood msg",new Message(BROADCAST_MSG_ID),module->getInterface(i),1000,100);
            }
        }
        //nbWaitedAnswers=sendMessageToAllNeighbors("flood msg",new Message(BROADCAST_MSG_ID),1000,100,1,sender);
        // if (nbWaitedAnswers==0) {
        //     //End of line blocks enter this
        //     subTreeSize = 1;
        //     sendMessage("ack2parent",new MessageOf<int>(ACKNOWLEDGE_MSG_ID, 1),parent,1000,100);//sends a message to one connected block
        //     module->setColor(BLUE);
        // }
    } 
    // else {
    //     //blocks that have already had their children talked to enter this
    //     sendMessage("ack2sender",new MessageOf(ACKNOWLEDGE_MSG_ID, 0),sender,1000,100);
    // }
}

void FaultToleranceCode::myAcknowledgeFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
    MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
    int msgData = *msg->getData();
    console << "At block: " << getId() << " maxd is: " << maxd << "\n";
    nbWaitedAnswers--;
    console << "rec. Ack(" << nbWaitedAnswers << ") from " << sender->getConnectedBlockId() << "\n";
    subTreeSize += msgData;
    if (nbWaitedAnswers==0) {
        subTreeSize += 1;
        if (parent==nullptr) {
            cout << "The total amount of modules that received the message: " << subTreeSize <<endl;
            // console << "the maxd is:" << maxd << "\n";
            // if(currentRound > 2) return;
            // // sendMessage("toMax", new Message(TOMAX_MSG_ID), maxInt, 1000, 100);
            // nbWaitedAnswers=sendMessageToAllNeighbors("distance(1,2)",new MessageOf<tuple<int,int,int>>(BROADCAST_MSG_ID,make_tuple(distance+1,currentRound,maxd)),1000,100,0);
        } else {
            sendMessage("ack2parent",new MessageOf(ACKNOWLEDGE_MSG_ID, subTreeSize),parent,1000,100);
            module->setColor(WHITE);
            //parent = nullptr;
        }
    }
}

// void FaultToleranceCode::myBroadcastFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {

//     MessageOf<tuple<int,int,int>>* msg = static_cast<MessageOf<tuple<int,int,int>>*>(_msg.get());
//     tuple<int,int,int> msgData = *msg->getData();

//     console << "rec. Flood (" << std::get<0>(msgData) << "," << std::get<1>(msgData) << ") from " << sender->getConnectedBlockId() << "\n";
//     console << "block: " << getId() << " has a distance of: " << distance << " and as parent: " << parent << "\n";
//     // cout << "module: " << module->blockId << " interface ID " << module->getInterfaceId(sender) << endl;
//     // if(brokenInterfaces[module->getInterfaceId(sender)] && sender->isConnected()) {
//     //     cout << catom->blockId <<": Trying to send a message on a broken interface(" << catom->getInterfaceId(sender) << ")" << endl;
//     //     return;
//     // }

//     if ( (parent==nullptr || std::get<0>(msgData)<distance || currentRound<std::get<1>(msgData)) ) {
//         distance=std::get<0>(msgData);
//         currentRound=std::get<1>(msgData);
//         parent=sender;
//         maxd=0;
//         string str="distance(";
//         str+=to_string(distance+1)+","+to_string(currentRound)+")";
//         nbWaitedAnswers=sendMessageToAllNeighbors(str.c_str(),new MessageOf<tuple<int,int,int>>(BROADCAST_MSG_ID,make_tuple(distance+1,currentRound,maxd)),1000,100,1,sender);
//         if (nbWaitedAnswers==0) {
//             //End of line blocks enter this
//             sendMessage("ack2parent",new MessageOf<int>(ACKNOWLEDGE_MSG_ID, maxd+1),parent,1000,100);//sends a message to one connected block
//             module->setColor(BLUE);
//         }
//     } 
//     else {
//             //blocks that have already had their children talked to enter this
//             sendMessage("ack2sender",new MessageOf(ACKNOWLEDGE_MSG_ID, maxd+1),sender,1000,100);
//     }
// }

// void FaultToleranceCode::myAcknowledgeFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
//     MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
//     int msgData = *msg->getData();
//     maxd = maxd + msgData;
//     console << "At block: " << getId() << " maxd is: " << maxd << "\n";
//     nbWaitedAnswers--;
//     console << "rec. Ack(" << nbWaitedAnswers << ") from " << sender->getConnectedBlockId() << "\n";
//     if (nbWaitedAnswers==0) {
//         if (parent==nullptr) {
//             cout << "The total amount of messages the leader module received: " << maxd <<endl;
//             // console << "the maxd is:" << maxd << "\n";
//             // if(currentRound > 2) return;
//             // // sendMessage("toMax", new Message(TOMAX_MSG_ID), maxInt, 1000, 100);
//             // nbWaitedAnswers=sendMessageToAllNeighbors("distance(1,2)",new MessageOf<tuple<int,int,int>>(BROADCAST_MSG_ID,make_tuple(distance+1,currentRound,maxd)),1000,100,0);
//         } else {
//             sendMessage("ack2parent",new MessageOf(ACKNOWLEDGE_MSG_ID, maxd+1),parent,1000,100);
//             module->setColor(WHITE);
//             //parent = nullptr;
//         }
//     }
// }

void FaultToleranceCode::fromBrokenFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender){
    nbWaitedAnswers--;
    cout << "broken " << sender->getConnectedBlockId() << endl;
    console << "rec. Brok(" << nbWaitedAnswers << ") from Broken " << sender->getConnectedBlockId() << "\n";
    if(nbWaitedAnswers==0){
        if (parent==nullptr) {
            cout << "The total amount of messages the leader module received: " << maxd <<endl;
        } else {
            sendMessage("ack2parent",new MessageOf(ACKNOWLEDGE_MSG_ID, maxd+1),parent,1000,100);
            module->setColor(WHITE);
        }
    }
}

void FaultToleranceCode::parseUserBlockElements(TiXmlElement *config) {
    const char *attr = config->Attribute("isA");
    isA = (attr?Simulator::extractBoolFromString(attr):false);
    if (isA) {
        std::cout << getId() << " is leader!" << std::endl; // complete with your code
    }
}

void FaultToleranceCode::parseUserElements(TiXmlDocument *config) {
  TiXmlNode *node = config->FirstChild("parameters");
  if (!node) return;
  TiXmlElement *element = node->ToElement();
}

void FaultToleranceCode::onMotionEnd() {
    // complete with your code
    console << " End of motion to " << module->position << "\n";
}

int FaultToleranceCode::sendMessage(const char *msgString, Message *msg, P2PNetworkInterface *dest, Time t0, Time dt) { 
    if(brokenInterfaces[module->getInterfaceId(dest)] && dest->isConnected()){
        console <<  module->blockId <<": Trying to send a message on a broken interface(" << module->getInterfaceId(dest) << ")" << "\n";
        cout << module->blockId <<": Trying to send a message on a broken interface(" << module->getInterfaceId(dest) << ")" << endl;
        return BlockCode::sendMessage("brk2parent",new MessageOf(BROKEN_MSG_ID, maxd),dest,1000,100);
    }             

    return BlockCode::sendMessage(msgString, msg, dest, t0, dt);
}


int FaultToleranceCode::breakInterface(P2PNetworkInterface* interface){
    // cout << interface->getConnectedBlockId() << endl; 
    // this->sourceInterface = nullptr;
    // cout << module->getInterfaceId(interface) << endl;
    brokenInterfaces[module->getInterfaceId(interface)] = true;
    // cout << module->blockId << " broken interface: " << module->getInterfaceId(interface) << endl;
    return 1;
}
//BaseSimulator::getWorld()->getN;
vector<pair<P2PNetworkInterface*, FaultToleranceCode*>>  FaultToleranceCode::getRandomInterfaces(float p) {
    vector<pair<P2PNetworkInterface*, FaultToleranceCode*>> interfaces;
    int nb_connected = 0;
    for(auto &it: BaseSimulator::getWorld()->getMap()) {
        auto m = static_cast<FaultToleranceCode*>(it.second->blockCode);
        for(auto ci: m->getAllConnectedInterfaces()) {
            nb_connected++;
            interfaces.push_back(make_pair(ci.second, m));
        }
    }
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(interfaces.begin(), interfaces.end(), g);
    cout << "nb_connected: " << nb_connected << endl;
    size_t numToSelect = static_cast<size_t>(p * interfaces.size());
    interfaces.resize(numToSelect);
    return interfaces;

}

int FaultToleranceCode::breakInterfaces(float p_interfaces) {
    auto I = FaultToleranceCode::getRandomInterfaces(p_interfaces);
    int nb = 0;
    for(auto it: I) {
        it.second->setColor(YELLOW);
        it.second->breakInterface(it.first);
        nb++;
    }

    return nb;

}