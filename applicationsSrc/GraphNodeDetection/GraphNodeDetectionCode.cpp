
/**
 * @file GraphNodeDetectionCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2024-03-23                                                                     
 **/
 
#include "GraphNodeDetectionCode.hpp"
#include <algorithm>
#include <random>

GraphNodeDetectionCode::GraphNodeDetectionCode(Catoms3DBlock *host):Catoms3DBlockCode(host),module(host) {
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host) return;

    // Registers a callback (myBroadcastFunc) to the message of type R
    addMessageEventFunc2(BROADCAST_MSG_ID,
                         std::bind(&GraphNodeDetectionCode::myBroadcastFunc,this,
                                   std::placeholders::_1, std::placeholders::_2));
    
    // Registers a callback (myAcknowledgeFunc) to the message of type K
    addMessageEventFunc2(ACKNOWLEDGE_MSG_ID,
                         std::bind(&GraphNodeDetectionCode::myAcknowledgeFunc,this,
                                   std::placeholders::_1, std::placeholders::_2));

    addMessageEventFunc2(BROKEN_MSG_ID,
                        std::bind(&GraphNodeDetectionCode::fromBrokenFunc,this,
                                std::placeholders::_1, std::placeholders::_2));


}


int GraphNodeDetectionCode::reachableModulesCount = 1;
map<int, int> GraphNodeDetectionCode::subgraphs;
void GraphNodeDetectionCode::startup() {
    console << "start " << getId() << "\n";
    //module->setColor(RED);
    if (module->blockId == 1){
        int nb = GraphNodeDetectionCode::breakInterfaces(0.001);
        cout << "nb:" << nb  << endl;
        //module->setColor(RED);
        currentRound=1;
        distance=0;
        maxd=0;
        initFlood();
        // isA = false;
        // GraphNodeDetectionCode::subgraphs[module->blockId] = 1;
        // for(int i=0; i<module->getNbInterfaces(); i++) {
        //     if(/*not brokenInterfaces[i] and*/ module->getInterface(i)->isConnected()) {
        //         sendMessage("flood msg",new MessageOf<int>(BROADCAST_MSG_ID, module->blockId),module->getInterface(i),1000,100);
        //         nbWaitedAnswers++;
        //     }
        // }
        //sendMessageToAllNeighbors("brk msg",new Message(BROKEN_MSG_ID),10000,1000,0);
    }
    
}

void GraphNodeDetectionCode::myBroadcastFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
    MessageOf<int> *msg = static_cast<MessageOf<int>*>(_msg.get());
    int root = *msg->getData();
    if(brokenInterfaces[module->getInterfaceId(sender)]){
         sendMessage("ack2sender",new MessageOf(ACKNOWLEDGE_MSG_ID, 0),sender,1000,100);
         return;
    }
    module->setColor(root);
    if ( parent==nullptr ) {
        reachableModulesCount++;
        isA = false;
        cout << "ReachableModulesCount: " << reachableModulesCount << endl;

        parent = sender;
        cout << "parent: " << parent << " ID: " << getId() << endl;
        for(int i=0; i<module->getNbInterfaces(); i++) {
            if(not brokenInterfaces[i] and module->getInterface(i)->isConnected() and module->getInterface(i) != sender) {
                sendMessage("flood msg",new MessageOf<int>(BROADCAST_MSG_ID, root),module->getInterface(i),1000,100);
                nbWaitedAnswers++;
            }
        }
        //nbWaitedAnswers=sendMessageToAllNeighbors("flood msg",new Message(BROADCAST_MSG_ID),1000,100,1,sender);
        if (nbWaitedAnswers==0) {
            //End of line blocks enter this
            sendMessage("ack2parent",new MessageOf<int>(ACKNOWLEDGE_MSG_ID, 1),parent,1000,100);//sends a message to one connected block
            //module->setColor(BLUE);
        }
    } 
    else {
        //blocks that have already had their children talked to enter this
        sendMessage("ack2sender",new MessageOf(ACKNOWLEDGE_MSG_ID, 0),sender,1000,100);
    }
}

void GraphNodeDetectionCode::fromBrokenFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender){
    // cout << getId() << " " << isA << endl;
    if (isA){
        // cout << "isA again" << endl;
        module->setColor(RED);
        currentRound=1;
        distance=0;
        maxd=0;
        nbWaitedAnswers=sendMessageToAllNeighbors("Start",new Message(BROADCAST_MSG_ID),10000,1000,0);
    }
    if (isC){
        sendMessageToAllNeighbors("brk msg",new Message(BROKEN_MSG_ID),10000,1000,0);
        isC = false;
    }
}


void GraphNodeDetectionCode::myAcknowledgeFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
    MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
    int msgData = *msg->getData();
    console << "At block: " << getId() << " maxd is: " << maxd << "\n";
    nbWaitedAnswers--;
    console << "rec. Ack(" << nbWaitedAnswers << ") from " << sender->getConnectedBlockId() << "\n";
    subTreeSize += msgData;
    if (nbWaitedAnswers==0) {
        subTreeSize += 1;
        if (parent==nullptr) {
            cout << "The total amount of modules that received the message: " << subTreeSize <<endl;
            subgraphs[module->blockId] = subTreeSize;
            GraphNodeDetectionCode* m = getUnreachedModule();
            if(m) {
                cout << "Unreached module: " << m->module->blockId << endl;
                m->initFlood();
                // m->isA = false;
                // GraphNodeDetectionCode::subgraphs[m->module->blockId] = 0;
                // for(int i=0; i<m->module->getNbInterfaces(); i++) {
                //     if(not m->brokenInterfaces[i] and m->module->getInterface(i)->isConnected()) {
                //         m->sendMessage("flood msg",new MessageOf<int>(BROADCAST_MSG_ID, m->module->blockId), m->module->getInterface(i),1000,100);
                //         m->nbWaitedAnswers++;
                //     }
                // } 
                // if (m->nbWaitedAnswers == 0) {
                //     GraphNodeDetectionCode::subgraphs[m->module->blockId] = 1;
                //     GraphNodeDetectionCode* m = getUnreachedModule();
                //     if(m) {
                //         m->initFlood();
                //     } else {
                //         cout << "done1\n";
                //         printSubgraphs();
                //     }
                // }
                
            } else {
                cout << "done2\n";
                printSubgraphs();
            }
            // console << "the maxd is:" << maxd << "\n";
            // if(currentRound > 2) return;
            // // sendMessage("toMax", new Message(TOMAX_MSG_ID), maxInt, 1000, 100);
            // nbWaitedAnswers=sendMessageToAllNeighbors("distance(1,2)",new MessageOf<tuple<int,int,int>>(BROADCAST_MSG_ID,make_tuple(distance+1,currentRound,maxd)),1000,100,0);
        } else {
            sendMessage("ack2parent",new MessageOf(ACKNOWLEDGE_MSG_ID, subTreeSize),parent,1000,100);
            //module->setColor(WHITE);
            //parent = nullptr;
        }
    }
}

void GraphNodeDetectionCode::onBlockSelected() {
    // Debug stuff:
    cout << module->blockId<< endl;
}

int GraphNodeDetectionCode::initFlood() {
    for(auto &it: BaseSimulator::getWorld()->getMap()) {
        auto m = static_cast<GraphNodeDetectionCode*>(it.second->blockCode);
        m->parent = nullptr;
        m->subTreeSize = 0;
        m->nbWaitedAnswers=0;
    }
    isA = false;
    GraphNodeDetectionCode::subgraphs[module->blockId] = 0;
     for(int i=0; i<module->getNbInterfaces(); i++) {
        if(not brokenInterfaces[i] and module->getInterface(i)->isConnected()) {
            sendMessage("flood msg",new MessageOf<int>(BROADCAST_MSG_ID, module->blockId),module->getInterface(i),1000,100);
            nbWaitedAnswers++;
        }
    }
    //nbWaitedAnswers=sendMessageToAllNeighbors("flood msg",new Message(BROADCAST_MSG_ID),1000,100,1,sender);
    if (nbWaitedAnswers==0) {
        GraphNodeDetectionCode::subgraphs[module->blockId] = 1;

        GraphNodeDetectionCode* m = getUnreachedModule();
        if(m) {
            m->initFlood();
        } else {
            cout << "done3\n";
            printSubgraphs();
        }
        //End of line blocks enter this
        //sendMessage("ack2parent",new MessageOf<int>(ACKNOWLEDGE_MSG_ID, 1),parent,1000,100);//sends a message to one connected block
        //module->setColor(BLUE);
    }
}

void GraphNodeDetectionCode::printSubgraphs() {
    cout << "subgraphs: \n";
    int total = 0;
    for (auto it: GraphNodeDetectionCode::subgraphs) {
        cout << "root: " << it.first << "->" << it.second << endl;
        total += it.second;
    }
    cout << "total: " << total << endl;
}

GraphNodeDetectionCode* GraphNodeDetectionCode::getUnreachedModule() {
    for(auto &it: BaseSimulator::getWorld()->getMap()) {
        auto m = static_cast<GraphNodeDetectionCode*>(it.second->blockCode);
        if(m->isA == true) {
            return m;
        }
    }
    return nullptr;
}

// void GraphNodeDetectionCode::myBroadcastFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {

//     MessageOf<tuple<int,int,int>>* msg = static_cast<MessageOf<tuple<int,int,int>>*>(_msg.get());
//     tuple<int,int,int> msgData = *msg->getData();

//     console << "rec. Flood (" << std::get<0>(msgData) << "," << std::get<1>(msgData) << ") from " << sender->getConnectedBlockId() << "\n";
//     console << "block: " << getId() << " has a distance of: " << distance << " and as parent: " << parent << "\n";
//     // cout << "module: " << module->blockId << " interface ID " << module->getInterfaceId(sender) << endl;
//     // if(brokenInterfaces[module->getInterfaceId(sender)] && sender->isConnected()) {
//     //     cout << catom->blockId <<": Trying to send a message on a broken interface(" << catom->getInterfaceId(sender) << ")" << endl;
//     //     return;
//     // }

//     if ( (parent==nullptr || std::get<0>(msgData)<distance || currentRound<std::get<1>(msgData)) ) {
//         distance=std::get<0>(msgData);
//         currentRound=std::get<1>(msgData);
//         parent=sender;
//         maxd=0;
//         string str="distance(";
//         str+=to_string(distance+1)+","+to_string(currentRound)+")";
//         nbWaitedAnswers=sendMessageToAllNeighbors(str.c_str(),new MessageOf<tuple<int,int,int>>(BROADCAST_MSG_ID,make_tuple(distance+1,currentRound,maxd)),1000,100,1,sender);
//         if (nbWaitedAnswers==0) {
//             //End of line blocks enter this
//             sendMessage("ack2parent",new MessageOf<int>(ACKNOWLEDGE_MSG_ID, maxd+1),parent,1000,100);//sends a message to one connected block
//             module->setColor(BLUE);
//         }
//     } 
//     else {
//             //blocks that have already had their children talked to enter this
//             sendMessage("ack2sender",new MessageOf(ACKNOWLEDGE_MSG_ID, maxd+1),sender,1000,100);
//     }
// }

// void GraphNodeDetectionCode::myAcknowledgeFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
//     MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
//     int msgData = *msg->getData();
//     maxd = maxd + msgData;
//     console << "At block: " << getId() << " maxd is: " << maxd << "\n";
//     nbWaitedAnswers--;
//     console << "rec. Ack(" << nbWaitedAnswers << ") from " << sender->getConnectedBlockId() << "\n";
//     if (nbWaitedAnswers==0) {
//         if (parent==nullptr) {
//             cout << "The total amount of messages the leader module received: " << maxd <<endl;
//             // console << "the maxd is:" << maxd << "\n";
//             // if(currentRound > 2) return;
//             // // sendMessage("toMax", new Message(TOMAX_MSG_ID), maxInt, 1000, 100);
//             // nbWaitedAnswers=sendMessageToAllNeighbors("distance(1,2)",new MessageOf<tuple<int,int,int>>(BROADCAST_MSG_ID,make_tuple(distance+1,currentRound,maxd)),1000,100,0);
//         } else {
//             sendMessage("ack2parent",new MessageOf(ACKNOWLEDGE_MSG_ID, maxd+1),parent,1000,100);
//             module->setColor(WHITE);
//             //parent = nullptr;
//         }
//     }
// }


void GraphNodeDetectionCode::parseUserBlockElements(TiXmlElement *config) {
    const char *attr = config->Attribute("isB");
    isB = (attr?Simulator::extractBoolFromString(attr):false);
    if (isB) {
        std::cout << getId() << " is leader!" << std::endl; // complete with your code
    }
}

void GraphNodeDetectionCode::parseUserElements(TiXmlDocument *config) {
  TiXmlNode *node = config->FirstChild("parameters");
  if (!node) return;
  TiXmlElement *element = node->ToElement();
}

void GraphNodeDetectionCode::onMotionEnd() {
    // complete with your code
    console << " End of motion to " << module->position << "\n";
}

int GraphNodeDetectionCode::sendMessage(const char *msgString, Message *msg, P2PNetworkInterface *dest, Time t0, Time dt) { 
    // if(brokenInterfaces[module->getInterfaceId(dest)] && dest->isConnected()){
    //     console <<  module->blockId <<": Trying to send a message on a broken interface(" << module->getInterfaceId(dest) << ")" << "\n";
    //     cout << module->blockId <<": Trying to send a message on a broken interface(" << module->getInterfaceId(dest) << ")" << endl;
    //     return BlockCode::sendMessage("brk2parent",new MessageOf(BROKEN_MSG_ID, maxd),dest,1000,100);
    // }             

    return BlockCode::sendMessage(msgString, msg, dest, t0, dt);
}


int GraphNodeDetectionCode::breakInterface(P2PNetworkInterface* interface){
    // cout << interface->getConnectedBlockId() << endl; 
    // this->sourceInterface = nullptr;
    // cout << module->getInterfaceId(interface) << endl;
    brokenInterfaces[module->getInterfaceId(interface)] = true;
    console << "brokenInterface: " << module->getInterfaceId(interface) << "\n";
    // cout << module->blockId << " broken interface: " << module->getInterfaceId(interface) << endl;
    return 1;
}
//BaseSimulator::getWorld()->getN;
vector<pair<P2PNetworkInterface*, GraphNodeDetectionCode*>>  GraphNodeDetectionCode::getRandomInterfaces(float p) {
    vector<pair<P2PNetworkInterface*, GraphNodeDetectionCode*>> interfaces;
    int nb_connected = 0;
    for(auto &it: BaseSimulator::getWorld()->getMap()) {
        auto m = static_cast<GraphNodeDetectionCode*>(it.second->blockCode);
        for(auto ci: m->getAllConnectedInterfaces()) {
            nb_connected++;
            interfaces.push_back(make_pair(ci.second, m));
        }
    }
    std::random_device rd;
    std::mt19937 g(rd());
    
    std::shuffle(interfaces.begin(), interfaces.end(), g);
    cout << "nb_connected: " << nb_connected << endl;
    size_t numToSelect = static_cast<size_t>(p * interfaces.size());
    interfaces.resize(numToSelect);
    return interfaces;

}

int GraphNodeDetectionCode::breakInterfaces(float p_interfaces) {
    auto I = GraphNodeDetectionCode::getRandomInterfaces(p_interfaces);
    int nb = 0;
    for(auto it: I) {
        it.second->setColor(YELLOW);
        it.second->breakInterface(it.first);
        nb++;
    }

    return nb;

}