
/**
 * @file mvtConnectivityCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2000-12-02                                                                     
 **/
 
#include "mvtConnectivityCode.hpp"

mvtConnectivity::mvtConnectivity(Catoms3DBlock *host):Catoms3DBlockCode(host),module(host) {
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host) return;

}

void mvtConnectivity::startup() {
    console << "start " << getId() << "\n";
    Catoms3DWorld* world = Catoms3D::getWorld();
    for (const auto& [pos, connectorID] : module->getAllFreeNeighborPos()) {
        if (Catoms3DMotionEngine::isBetweenOppositeOrDiagonalBlocks(world->lattice, pos)) continue;
        graphEdges[pos];
        console << "Free Position: " << static_cast<int>(connectorID) << ", " << pos << "\n";
        for (const auto&[pos1, connectorIDto] : module->getAllFreeNeighborPos()) {
            const Catoms3DMotionRulesLink* linkH = Catoms3DMotionEngine::findPivotConnectorLink(module, connectorID, connectorIDto, HexaFace);
            const Catoms3DMotionRulesLink* linkO = Catoms3DMotionEngine::findPivotConnectorLink(module, connectorID, connectorIDto, OctaFace);

            if ((linkH != nullptr || linkO != nullptr) && !Catoms3DMotionEngine::isBetweenOppositeOrDiagonalBlocks(world->lattice, pos1)) {
                int connectorintIDto = static_cast<int>(connectorIDto);
                console << "(" << connectorintIDto << ", " << pos1 << ")\n";
                graphEdges[pos].emplace_back(pos1);
            }
        }
    }
    nbWaitedAnswers = sendHMessageToAllNeighbors(new FPCheckMessage(module->position, graphEdges),10000,1000,0);
}

void mvtConnectivity::processLocalEvent(EventPtr pev) {
    MessagePtr message;
    stringstream info;

    // Do not remove line below
    Catoms3DBlockCode::processLocalEvent(pev);

    switch (pev->eventType) {
        case EVENT_RECEIVE_MESSAGE: {
            message = (std::static_pointer_cast<NetworkInterfaceReceiveEvent>(pev))->message;

            if (message->isMessageHandleable()) {
                std::shared_ptr<HandleableMessage> hMsg =
                    (std::static_pointer_cast<HandleableMessage>(message));

                console << "Received " << hMsg->getName() << " from "
                        << message->sourceInterface->hostBlock->blockId
                        << " at " << getScheduler()->now() << "\n";
                hMsg->handle(this);
            }
        }
        case EVENT_ADD_NEIGHBOR: 
            // Do something when a neighbor is added to an interface of the module
        break;

        case EVENT_REMOVE_NEIGHBOR: 
            // Do something when a neighbor is removed from an interface of the module
        break;        

        case EVENT_INTERRUPTION: 
            // Do something when the module receives an event
        break;
    }
}

void mvtConnectivity::onMotionEnd() {
    // complete with your code
    console << " End of motion to " << module->position << "\n";
}

void mvtConnectivity::onBlockSelected() {
    std::cout << "Block selected" << std::endl; // complete with your code here
}

string mvtConnectivity::onInterfaceDraw() {
    return "My text\nIn two lines"; // to update with your text
}

int mvtConnectivity::sendHMessage(HandleableMessage *msg,P2PNetworkInterface *dest,Time t0,Time dt) {
    return BlockCode::sendMessage(msg, dest, t0, dt);
}

int mvtConnectivity::sendHMessageToAllNeighbors(HandleableMessage *msg, Time t0, Time dt, int nexcept, ...) {
    return BlockCode::sendMessageToAllNeighbors(msg, t0, dt, nexcept);
}