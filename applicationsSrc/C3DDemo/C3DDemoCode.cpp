
/**
 * @file C3DDemoCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2023-09-20                                                                     
 **/
 
#include "C3DDemoCode.hpp"

map<Cell3DPosition, vector<Cell3DPosition>> C3DDemoCode::cells;
vector<Cell3DPosition> C3DDemoCode::visited;
vector<Cell3DPosition> C3DDemoCode::teleportedPositions;

C3DDemoCode::C3DDemoCode(Catoms3DBlock *host):Catoms3DBlockCode(host),module(host) {
  if (not host) return;

      /*addMessageEventFunc2(SAMPLE_MSG_ID,
          std::bind(&CatomsTest1BlockCode::handleSampleMessage, this,
                    std::placeholders::_1, std::placeholders::_2));
      addMessageEventFunc2(BACK_MSG_ID,
          std::bind(&CatomsTest1BlockCode::handleBackMessage, this,
                    std::placeholders::_1, std::placeholders::_2));
  */
      module = static_cast<Catoms3DBlock*>(hostBlock);
}

// void C3DDemoCode::startup() {
//     console << "start " << getId() << "\n";
//     if (isLeader) { // At least one module must be "leader" in the config file
//         moveToFirst();
//         setColor(YELLOW);
//         vector<std::pair<const Catoms3DMotionRulesLink*, Catoms3DRotation>> motions = Catoms3DMotionEngine::getAllRotationsForModule(module);
//         for(int i =0;i<motions.size();i++){
//         cout<<"["<<*motions[i].first<<","<<motions[i].second.pivot->blockId<<"]"<< std::endl;
//         }
//         currentRound=1;
//         distance=0;
//         maxd=distance;
//         nbWaitedAnswers=sendMessageToAllNeighbors("distance(1,1)",new MessageOf<tuple<int,int,int>>(BROADCAST_MSG_ID,make_tuple(distance+1,currentRound,getId())),1000,100,0);
//     } else {
//         currentRound=0;
//     }
// 	VS_ASSERT_MSG(target, "Target is null, aborting...");
// }

void C3DDemoCode::startup() {
    if (module->blockId == 26) {//26 24
        module->setColor(RED);
        distance = 0;
        //floodDistance();
        Cell3DPosition currentPosition = module->position;
        cells[currentPosition] = vector<Cell3DPosition>();
        teleportedPositions.push_back(currentPosition);
        for(auto &pos: module->getAllMotions()) {
           cells[currentPosition].push_back(pos.first);
            visited.push_back(pos.first);
            parentMap[pos.first] = currentPosition;
        }
        console << "Printing cells map:\n";
        for (const auto &entry : cells) {
            // entry.first is the key (module->position)
            // entry.second is the vector of Cell3DPosition
            console << "Position: " << entry.first << " -> ";
            console << "Connected Positions: ";
            for (const auto &cellPos : entry.second) {
                console << cellPos << " "; // Assuming operator<< is defined for Cell3DPosition
            }
            console << "\n";
        }
        getScheduler()->schedule(new TeleportationStartEvent(getScheduler()->now() + 1000, module, *cells[currentPosition].begin()));
        console << "First position in cells[currentPosition]: " << *cells[currentPosition].begin() << "\n";
    } else if (module->blockId == 31){
        module->setColor(PURPLE);
        auto freeNeighbors = module->getAllFreeNeighborPos();
        for(const auto& [pos, connectorID] : freeNeighbors) {
            console << "Free position: " << pos << " via connector: " << (int)connectorID << "\n";
        }
    } else {
        distance = -1;
        hostBlock->setColor(LIGHTGREY);
    }
}

void C3DDemoCode::onMotionEnd() {
    // console << " has reached its destination\n";
    module->exportMatrix();
}

void C3DDemoCode::processLocalEvent(EventPtr pev) {
    Catoms3DBlockCode::processLocalEvent(pev);

    switch (pev->eventType) {
        case EVENT_TELEPORTATION_END:
            // Return journey handling
            if (isReturning) {
                if (!discoveredPath.empty()) {
                    // Get the next position in the return path
                    Cell3DPosition nextPosition = discoveredPath.back();
                    discoveredPath.pop_back(); // Remove it from the path

                    // console << "Returning: Teleporting to " << nextPosition << "\n";

                    // Schedule teleportation to the next position
                    getScheduler()->schedule(
                        new TeleportationStartEvent(getScheduler()->now() + 1000, module, nextPosition)
                    );
                } else if (currentTarget != originalTarget) {
                    isReturning = false;
                    // Currently used as a bridge
                } else if (module->position != originalTarget){
                    // Return journey complete
                    // console << "Return journey complete. Back at the initial position.\n";
                    using NeighborsContainer = typename std::remove_reference<decltype(module->getNeighbors())>::type;
                    std::vector<NeighborsContainer::value_type> neighbors;
                    console << "Type: " << typeid(NeighborsContainer).name() << "\n";

                    for (auto i : module->getNeighbors()) {
                        console << *i << "\n";
                        neighbors.push_back(i); // Now correctly stores the neighbors
                    }
                    isReturning = false;
                    finalJourney = true;
                    discoveredPath = optimalPath;
                    std::reverse(discoveredPath.begin(), discoveredPath.end());
                    Cell3DPosition nextPosition;
                    while (!discoveredPath.empty() && discoveredPath.back() == module->position) {
                        discoveredPath.pop_back();
                    }
                    if (!discoveredPath.empty()) {
                        nextPosition = discoveredPath.back();
                    }
                    discoveredPath.pop_back(); // Remove it from the path
                    getScheduler()->schedule(new Catoms3DRotationStartEvent(getScheduler()->now() + 1000, module, nextPosition, 
                    RotationLinkType::Any, false));
                } else {
                    isReturning = false;
                }
            }
            // Discovery phase handling
            else if (!visited.empty() && module->position != currentTarget) {
                // Get the next position to explore
                Cell3DPosition nextPosition = visited.back();
                visited.pop_back();
                teleportedPositions.push_back(nextPosition);

                // Track parent-child relationship
                if (parentMap.find(nextPosition) == parentMap.end()) {
                    parentMap[nextPosition] = module->position;
                }

                // Discover adjacent positions
                for (auto &pos : module->getAllMotions()) {
                    cells[module->position].push_back(pos.first);
                    if (std::find(visited.begin(), visited.end(), pos.first) == visited.end() &&
                        std::find(teleportedPositions.begin(), teleportedPositions.end(), pos.first) == teleportedPositions.end()) {
                        visited.push_back(pos.first);
                        parentMap[pos.first] = module->position; // Track parent
                    }
                }

                // Schedule the next teleportation
                getScheduler()->schedule(
                    new TeleportationStartEvent(getScheduler()->now() + 1000, module, nextPosition)
                );
            }
            else if (visited.empty() && module->position != currentTarget){
                Cell3DPosition closestPosition = module->position;
                double minDistance = std::numeric_limits<double>::max();

                for (const auto &pos : teleportedPositions) {
                    double distance = calculateDistance(pos, originalTarget);
                    if (distance < minDistance) {
                        closestPosition = pos;
                        minDistance = distance;
                    }
                }

                // Set the closest position as the new target
                currentTarget = closestPosition;

                console << "Switching target to the closest position: " << currentTarget << "\n";
                // Find straight path to new target
                isReturning = true; // Set return flag
                discoveredPath.clear();
                Cell3DPosition current = module->position;
                while (parentMap.find(closestPosition) != parentMap.end()) {
                    if(closestPosition == current){
                        break;
                    }
                    discoveredPath.push_back(closestPosition);
                    closestPosition = parentMap[closestPosition];
                }
                // Output the optimal path
                optimalPath.assign(discoveredPath.begin(), discoveredPath.end());
                console << "Optimal path from start to new goal:\n";
                for (auto &pos : optimalPath) {
                    console << pos << "\n";
                }
                // Start the return journey
                if (!discoveredPath.empty()) {
                    Cell3DPosition nextPosition = discoveredPath.back();
                    discoveredPath.pop_back();

                    // console << "Starting return journey: Teleporting to " << nextPosition << "\n";
                    getScheduler()->schedule(
                        new TeleportationStartEvent(getScheduler()->now() + 1000, module, nextPosition)
                    );
                }
                // Restart BFS from current position
                // visited.clear();
                // teleportedPositions.clear();
                // teleportedPositions.push_back(module->position);
                // visited.push_back(module->position);

                // for (auto &pos : module->getAllMotions()) {
                //     cells[module->position].push_back(pos.first);
                //     if (std::find(visited.begin(), visited.end(), pos.first) == visited.end() &&
                //         std::find(teleportedPositions.begin(), teleportedPositions.end(), pos.first) == teleportedPositions.end()) {
                //         visited.push_back(pos.first);
                //         parentMap[pos.first] = module->position; // Track parent
                //     }
                // }
                // getScheduler()->schedule(new TeleportationStartEvent(getScheduler()->now() + 1000, module, *cells[module->position].begin()));
            }
            // Goal reached handling
            else if (module->position == currentTarget) {
                // console << "Goal reached. Reconstructing optimal path...\n";
                isReturning = true; // Set return flag

                // Backtrack from goal to start
                discoveredPath.clear();
                Cell3DPosition current = module->position;

                while (parentMap.find(current) != parentMap.end()) {
                    discoveredPath.push_back(current);
                    current = parentMap[current];
                }
                discoveredPath.push_back(current); // Add the start position

                std::reverse(discoveredPath.begin(), discoveredPath.end()); // Reverse to start-to-goal order

                optimalPath.assign(discoveredPath.begin(), discoveredPath.end());
                // Output the optimal path
                console << "Optimal path from start to goal:\n";
                for (auto &pos : discoveredPath) {
                    console << pos << "\n";
                }

                // Start the return journey
                if (!discoveredPath.empty()) {
                    Cell3DPosition nextPosition = discoveredPath.back();
                    discoveredPath.pop_back();

                    // console << "Starting return journey: Teleporting to " << nextPosition << "\n";
                    getScheduler()->schedule(
                        new TeleportationStartEvent(getScheduler()->now() + 1000, module, nextPosition)
                    );
                }
            }
            break;
        case EVENT_ROTATION3D_END: {
            if (finalJourney) {
                module->setColor(BLUE);
                if (!discoveredPath.empty()){
                    Cell3DPosition nextPosition;
                    while (!discoveredPath.empty() && discoveredPath.back() == module->position) {
                        discoveredPath.pop_back();
                    }
                    if (!discoveredPath.empty()) {
                        nextPosition = discoveredPath.back();
                    }
                    discoveredPath.pop_back(); // Remove it from the path
                    getScheduler()->schedule(new Catoms3DRotationStartEvent(getScheduler()->now() + 1000, module, nextPosition, 
                    RotationLinkType::Any, false));
                }
                else {

                }
            }
        }break;
        default:
            break;
    }
}



void C3DDemoCode::onBlockSelected() {
    cerr << endl << "--- PRINT MODULE " << *module << "---" << endl;
}

void C3DDemoCode::onAssertTriggered() {
    console << " has triggered an assert\n";
}

bool C3DDemoCode::parseUserCommandLineArgument(int &argc, char **argv[]) {
    if ((argc > 0) && ((*argv)[0][0] == '-')) {
        switch((*argv)[0][1]) {
            case 'b': {
                cout << "-b option provided" << endl;
                return true;
            } break;

            case '-': {
                std::string varg = std::string((*argv)[0] + 2);
                if (varg == std::string("foo")) {
                    int fooArg;
                    try {
                        fooArg = stoi((*argv)[1]);
                        argc--;
                        (*argv)++;
                    } catch(std::logic_error&) {
                        std::stringstream err;
                        err << "foo must be an integer." << endl;
                        throw CLIParsingError(err.str());
                    }
                    cout << "--foo option provided with value: " << fooArg << endl;
                } else return false;
                return true;
            }

            default: cerr << "Unrecognized command line argument: " << (*argv)[0] << endl;
        }
    }
    return false;
}

std::string C3DDemoCode::onInterfaceDraw() {
    std::stringstream trace;
    trace << "Distance: " << distance;
    return trace.str();
}

double C3DDemoCode::calculateDistance(const Cell3DPosition &a, const Cell3DPosition &b) {
    return std::sqrt(std::pow(b.pt[0] - a.pt[0], 2) + std::pow(b.pt[1] - a.pt[1], 2) + std::pow(b.pt[2] - a.pt[2], 2));
}